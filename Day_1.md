１日目　SLIPモデルを用いたシミュレーションを実現しよう

# 注意事項
本資料をもとに授業を進めます．
本資料に従ってプログラミングをおこない，課題と問について解いてください．（応用課題については，すべての課題を終えた人だけ解いてください．基本的には課題を解いてもらえれば合格です．）
課題の解答は，レポートにまとめて提出していただきます．詳細は[ReadMe](https://github.com/amby-1/sogoenshu_2023/blob/main/README.md)をよく読んで下さい．

# 概要
スライドを用いて説明予定．

# バネダンパ系の運動シミュレーション
練習問題として，バネでつるされた質点の運動を数値的にシミュレーションしながら，これまで学んだ微分方程式の数値解法を復習する．

## 問題設定
図のように重力下(重力加速度: $g$)で天井から質点（質量: $m$）が線形バネ(バネ定数: $k$)とダンパ(ダンパ定数: $c$)で釣られているシステムを考える．
この時，バネのつり合いの位置を原点として，鉛直上向き方向を正とする座標系を定義し，質点の位置を $x$と表す．バネに重りを付けなかった際（自然長時）のバネ先端の位置を $x_n = mg/k$とする．
さらに，質点には任意の外力 $u$も及ぼされるものとする（実際には接触なく外力を与えるのは難しいが，磁気等を使って外力を非接触で制御できると考えることとする）．

<img src="Figs/model1.png" width="300" alt="バネ質点モデル">

このとき，質点に対して時刻 $t=0$で初期位置と速度 $(x_0, \dot{x}_0)$を与えた際に，質点の運動がどのように時間発展するかを数値計算で確かめる．

## 運動方程式の導出
この質点の運動方程式は，ニュートンの運動方程式の導出方法で簡単に導出することができるが，ここではオイラーラグランジュの運動方程式を使った導出法を復習する．
まず，システムの一般化座標 $q$を定義する必要がある．ここでは，質点の位置 $x$を一般化座標 $q$として定義する．この時，ラグランジアン $L = T - V$（ $T$: 運動エネルギー, $V$: ポテンシャルエネルギー）は，以下のようにかける．
$$L = \frac{1}{2} m \dot{q}^2 - m g q - \frac{1}{2} k {(x_n - q)}^2$$
また，システムの散逸関数 $D$は，ダンパによる抵抗力を考えて以下でかける．
$$D = \frac{1}{2} c \dot{q}^2 $$
散逸関数は授業で扱われていないかもしれない．散逸関数(スカラー)は，速度のみに依存する抵抗力 $f_i$に対して， $f_i = - \frac{\partial D}{\partial \dot{q_i}}$と定義される( $i$は一般化座標 $q$の要素に対応する)．
もし，システムが，ポテンシャルや散逸関数以外に一般化力を持たなければ，全エネルギー $E$の時間発展は $\frac{dE}{dt} = - D$とかける．つまり，散逸関数の物理的意味は，単位時間あたりに抵抗力により失うエネルギーを表している．

つぎに，このシステムの一般化力 $Q$は，質点にかかる外力である $u$と表すことができる．
以上から，$q_i$に対するオイラーラグランジュ方程式
$$\frac{d}{dt} \frac{\partial L}{\partial \dot{q}_i} - \frac{\partial L}{\partial q_i} = - \frac{\partial L}{\partial \dot{q}_i} + Q_i $$
を用いることで，このシステムの運動方程式は，
$$m \ddot x + c \dot{x} + k {x} = u$$
と導出することができる．
```
問1 上記を実際に計算して確認せよ
```

## 運動方程式の数値解法
多くの場合，運動シミュレーションは微分方程式（運動方程式）を数値的に解くことに帰着される．
今回の問題では， $u$が特定の関数の場合（例えば $u$が時間に依存しない場合など）には解析的に解くことができる（厳密解が導出できる）．
しかし， $u$が任意の時間関数になった場合には，解析的な解を求めるのは難しい．
ここでは，２種類の数値解法を用いて，この運動方程式（微分方程式）の時間発展を計算する．

### オイラー法
微分方程式
$$\dot{x} = f(t, x)$$
が与えられた時に，微小時間ステップ $\Delta t$を設定し，時刻 $t+\Delta t$の状態 $x$を
$$x(t+\Delta t) = x(t) + f(t, x)  \Delta t$$
として近似計算する方法．前ステップの値に，時間変化に対する傾き $f(t, x)$ と 時間ステップ $\Delta t$　をかけたものを加えていく計算となっている．
実装は非常に簡単だが，誤差が蓄積しやすいデメリットがある．

### ルンゲクッタ(4次)法
オイラー法はシステムの挙動を点 $(x(t); t)$において線形近似し， $x(t + \Delta t)$ の値を求めたが，テイラー展開を用いるとより詳細な近似が可能になる．
ルンゲクッタ法（4次）は， $x(t+\Delta t)$の4次の項までのテイラー展開と結果が一致するようにした方法である．
テイラー展開するには， $x$の高次の時間微分（ $f(t,x)$の高次時間微分）が必要になるが，それを用いることなく $f(t,x)$のみを使って4次の近似を可能にしたのがルンゲクッタ法である．
詳細には踏み込まないが，計算式は以下である．
$$x(t + \Delta t) = x(t) + \frac{k_1 + 2k_2 + 2k_3 + k_4}{6} \Delta t $$
なお，
```math
k_1 = f(t, \, x(t)), \:   k_2 = f(t + \Delta t /2, \, x(t) + k_1 \Delta t /2) , \: k_3 = f(t + \Delta t /2, \, x(t) + k_2 \Delta t /2) ,  \: k_4 = f(t + \Delta t, \, x(t) + k_3 \Delta t)
```
それほど複雑でない計算で，4次の精度を得ることができる．
そのため，ロボット等のシミュレーションでは良く用いられる数値計算法である．

## プログラムの実装
上記2つの数値解法を用いて質点の運動の時間発展を求めるが，システムの運動方程式
$$m \ddot x + c \dot{x} + k {x} = u$$ 
は2階の微分方程式であり，上記で議論した1階の微分方程式に変換する必要がある．

制御工学で学んだように，2階の微分方程式は変数をあらたに増やすことで，1階の微分方程式にできる．本システムの場合は， $y = \dot x$ なる変数を増やすことによって，以下の1階の微分方程式に帰着できる．
```math
\frac{d}{dt}
\left[
\begin{matrix}
x \\ 
y
\end{matrix}
\right]
= 
\left[
\begin{matrix}
y \\ 
(- c \dot{x} - k {x} + u ) /  m 
\end{matrix}
\right]
``` 
なお，微分方程式で微分される変数（この場合は $(x, y)$）を，制御ではシステムの状態変数と呼んでいた．

```
課題1 オイラー法とルンゲクッタ法を用いて，運動方程式を数値計算するプログラムを書け．
なお，外力uは時間のみに依存する関数としてプログラム内で定義しておいてください．
また，以下で指定する数値例で運動方程式を解け．
```
### 物理パラメタ等
作成したプログラムを使って，以下の物理パラメタの下，ダンパ係数 $c$を様々に変化させて，システムの応答を確認してみてください． $u(t)=0$としてください．
| 変数 | 値   |   変数 | 値 |
| ------- | --------- | --------- | ------- |
| $m$   | 1 [kg]     |     $x(0)$ |  1 [m]   |
| $k$   | 10 [N/m]    |     $\dot{x}(0)$ |  0 [m]   |
| 刻み幅 $dt$   | 0.01 [s]     |     シミュレ時間 $T$ | 10 [s]   |

ダンパ係数を４種類変化させて（0, 3, 6, 9）， $x$の時間変化のグラフをルンゲクッタ法を用いて作ってください．

<img src="Figs/kadai1.png" width="400" alt="課題１">

これまでの授業で培ってきた直観とあっているでしょうか？

### 課題1のヒント
C++言語の場合を例としてプログラムの構築例を示す．TODOと書かれたところは自分で書いてください．
（特にこのように書けという指示ではないため，プログラミングに慣れた方は自由にコーディングしてください．）

```cpp :example1.cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <fstream>

// 定数の設定
const double g = 9.8;  // 重力加速度 [m/s^2]

// クラスの定義
//  運動方程式の状態量や物理パラメタを管理しており，step_?? 関数を呼び出すことで状態量の時間を１ステップ(dt)進める機能を提供する
class Spring_mass {
private: 
    // メンバ変数
    double m;        // 質量 [kg]
    double k;        // バネ定数 [N/m]   
    double c;        // ダンパ係数 [Ns/m]  
    double x;        // 位置 [m]  　　＊時間とともに変化します．
    double dx;       // 速度 [m/s]　　＊時間とともに変化　
    double t;     // 時間 [s]　＊時間とともに変化

public:
    // コンストラクタ -- 変数を初期化する
    //  初期時間はゼロとしている
    //   m(m_) は，メンバ変数 m を m_ で初期化するという文法です．他も同様
    Spring_mass(double m_, double k_, double c_, double x_, double dx_) : m(m_), k(k_), c(c_), x(x_), dx(dx_), t(0.){}

    // 制御入力の計算式
    double func_u(double t){
        return 0.;
    }

    // 時間発展の方程式
    double func_dx(double t_, double x_, double dx_){
        // ここにdx/dt の時間発展の式を書く (dx/dt)
        return TODO; 
    }
    double func_ddx(double t_, double x_, double dx_){
        // ここにddx / ddt 時間発展の式を書く (dy/dt)
        return TODO;
    }

    // 1ステップ計算させる
    // euler法
    void step_euler(double dt) {
        TODO
    }

    // Runge kutta法
    void step_rk4(double dt) {
        TODO
    }

    // データを取り出す
    double get_x(){
        return x;
    }
    double get_dx(){
        return dx;
    }
    double get_t(){
        return t;
    }
    double get_u(){
        return func_u(t);
    }
};

int main() {
    // パラメータの設定
    double m = 1.;           // 質量 [kg]
    double k = 10.;           // バネ定数 [N/m]   
    double c = 1.;           // ダンパ係数 [Ns/m]  

    double ini_x = 1.;        // 初期位置 [m]
    double ini_dx = 0.;       // 初期速度 [m/s]
    
    double dt = 0.01;            // タイムステップ [s]
    double total_time = 10.0;    // 総計算時間 [s]

    Spring_mass spring_mass(m, k, c, ini_x, ini_dx); // 上で作ったクラスを呼び出す

    std::ofstream ofs("data_runge.dat"); // データを保存するためのファイルを開く

    for (double t = 0.; t < total_time; t += dt) { // 毎ステップ，微分方程式を数値的に解く
        ofs << spring_mass.get_t() << ", " << spring_mass.get_x()  << ", " << spring_mass.get_dx() << std::endl;  // 時間と状態量をクラスから読み出し，ファイルに保存  　ファイルへの保存の仕方はC言語よりも直観的だと思います． std::endl で改行されます．
        spring_mass.step_rk4(dt); // ルンゲクッタ法のstep関数を呼び出して，時間と状態量を次のステップに進める
    }

    ofs.close();  // ファイルを閉じる

    std::cout << "Calculation completed and data has been saved -- sim duration is " << total_time << " [s]" << std::endl; // こんな感じでコンソールにメッセージを出せます．デバッグに活用してください．

    return 0;
}

```
簡単にサンプルプログラムの説明を行う．サンプルプログラムでは，クラス`Spring_mass`を用いて運動方程式に関わる変数の管理と，シミュレーションのための関数を機能として提供している．
クラスになじみがないかもしれない．詳細は参考文献に譲る．
誤解を恐れず簡単に述べると，クラスは「関数（メンバ関数）と変数（メンバ変数）を含む 構造体`struct`であり，メンバ関数を通して自在にメンバ変数を変更できる」程度に考えてもらえれば良い．

このクラスは，メンバ変数として運動方程式の物理変数，状態量，時間を保持している．
```cpp
private: 
    // メンバ変数
    double m;        // 質量 [kg]
    double k;        // バネ定数 [N/m]   
    double c;        // ダンパ係数 [Ns/m]  
    double x;        // 位置 [m]  　　＊時間とともに変化します．
    double dx;       // 速度 [m/s]　　＊時間とともに変化　
    double t;     // 時間 [s]　＊時間とともに変化
```
`private:`の記載は，クラス内部のメンバ関数でしか変数にアクセスできないという意味である（状態変数は運動方程式のみで決まるものなので，`main`など外から勝手に触られないように隠ぺいしている程度の理解で良い）．

本クラスはメンバ関数として多くの関数を持っている．最初の関数のようなものは，コンストラクタと呼ばれ，クラスを定義する際に必ず実行されるものである．ここでは，物理変数や状態変数の初期化を行っている．
```cpp
Spring_mass(double m_, double k_, double c_, double x_, double dx_) : m(m_), k(k_), c(c_), x(x_), dx(dx_), t(0.){}
```

以下の関数は，各状態変数の微分方程式 $\dot x = f_x(t, x, y), \dot y = f_y(t, x, y)$ ( $y$はプログラム内のdx)の右辺に対応している，
```cpp
double func_dx(double t_, double x_, double dx_){
    // ここにdx/dt の時間発展の式を書く (dx/dt)
    return TODO; 
}
double func_ddx(double t_, double x_, double dx_){
    // ここにddx / ddt 時間発展の式を書く (dy/dt)
    return TODO;
}
```

以下の関数`step_????(double dt)`で，微小時間 $\Delta t$ (dt) 後の状態変数の時間発展を，上記関数`func_???()`を用いて計算している．変数`x, dx, t`の値が更新されるはずである． 
```cpp
// euler法
void step_euler(double dt) {
    TODO
}
// Runge kutta法
void step_rk4(double dt) {
    TODO
}
```

最後に，main関数からクラス内のメンバ変数を取り出すための関数が定義されている(`get_?()`)


次に，main関数内部の説明を行う．
```cpp
Spring_mass spring_mass(m, k, c, ini_x, ini_dx); // 上で作ったクラスを呼び出す
```
上記コマンドによって，上記のクラス`Spring_mass`を実体`spring_mass`として定義する．なお，コンストラクタを同時に呼び出して初期化している．

次に，データを保存するためのファイルを作成し，
```cpp
std::ofstream ofs("data_runge.dat"); // データを保存するためのファイルを開く
```

`for`ループを用いて，微小時間ごとに`spring_mass`クラスの`step_??()`関数を呼び出し，クラス内の状態変数を更新する．また，ファイルへと状態変数を保存する．
```cpp
for (double t = 0.; t < total_time; t += dt) { // 毎ステップ，微分方程式を数値的に解く
    ofs << spring_mass.get_t() << ", " << spring_mass.get_x()  << ", " << spring_mass.get_dx() << std::endl;  
    spring_mass.step_rk4(dt); // ルンゲクッタ法のstep関数を呼び出して，時間と状態量を次のステップに進める
}
```
以上が大まかなプログラムの流れである．


得られた結果の時間データは，グラフにプロットしないと良く分からない．グラフ作成には様々なツールが存在し，何をつかっても構わない．
ここでは，gnuplotを使った場合のプログラムの一例を示す．
```plaintext
# プロットの設定
set title "Spring Mass Model Time Evolution"
set xlabel "Time [s]"
set ylabel "Position [m]"
set grid

# データのプロット
plot "data_test.dat" using 1:2 with lines title "x(t) from Euler"
replot "data_runge.dat" using 1:2 with lines title "x(t) from RK4"


# グラフを保存
set terminal pngcairo
set output "test_plot.png"
replot

# プロットを画面に表示
pause mouse
```

## プログラムの妥当性の検証
実装したプログラムがうまく動いているか，バグがないかを調べる必要がある．
微分方程式の解析解は求まらない場合がほとんどのため，この検証は難しい場合が多い．
しかし，今回に限っては， $u=0, c=0$の時には解析的に解を導出可能であり，解析解と比較することでプログラムを検証する．

$u=0, c=0$の場合の一般解は，以下のように求めることができる．
$$x = a \cos (\omega t + \phi)$$ 
なお， $\omega$は， $m,k$を用いて表すことができ， $a, \phi$は初期状態に応じて決まる量である．
```
問2 上記を実際に計算して，シミュレーション条件での解析解を求めよ．
```
```
応用課題1 ダンパが存在する場合でも解析解は求めることができる．
解析解を求め，シミュレーションと比較してみよ．
```
<!-- omega = \sqrt(k / m) , a = 1, phi = 0 -->

プログラムの妥当性を確認する方法は様々なやり方が考えられる．
一番簡単なやり方は，解析解と数値計算結果の時間発展を実際にプロットして，数値計算結果が解析解（真値）からずれないことを定性的に確認する事である．
```
課題2 u=0, c=0, シミュレーション時間 50[s], dt = 0.2[s]（それ以外は課題１と同じ条件）において，
位置xの時間変化を，解析解（真値）とオイラー法，ルンゲクッタ法とで比較せよ．
また，相図（横軸縦軸を状態空間の(x,y)にしたもの）をプロットし，同様に確かめよ．結果について誤差の観点から考察せよ．
```

しかし，このやり方では，定性的にプログラムがあっていそうなことは確かめられても，定量的に妥当なのかは良く分からない．
真値とのずれが，数値計算で想定される誤差程度に収まっているのか評価できていない．

そこで，ここでは以下のように，位置に対して１[s]後の絶対誤差 $e$を定義し，この誤差が $dt$を変えた時にどのように小さくなっていくかをもとに，プログラムの妥当性を定量的に評価する．
```math
e_{\Delta t} = | x_{\Delta t}(1) - \hat{x}(1) |
``` 
なお， ${x}_{\Delta t}$は，オイラー法またはルンゲクッタ法で $\Delta t$刻みで計算した位置であり， 
 $\hat{x}$は真値であるとする．

```
課題3 絶対誤差 e が，dt に対してどのように変化するかを両対数グラフで示せ（オイラー法とルンゲクッタ法それぞれについて）．
なお，シミュレーションの初期値や物理パラメタ等は，課題1と同じものをもちいて構わない．(なお，u=c=0)．
オイラー法やルンゲクッタ法の計算精度（理論）をもとに，プログラムが妥当であるかどうかについて考察してみよ．
また，dtを小さくしてもeの精度が良くならない状況があった場合が，その理由も考察せよ．
```
ヒント：　これは少し難しい課題である．正確なプログラムがかけていないと，ルンゲクッタ法が理論通りの高精度にならない．
ルンゲクッタ法の精度がオイラー法程度しか出ない場合，以下の可能性も疑ってください．
評価をおこなう時刻（今回は  $t=1$ [s]）がプログラム上で正確か？（サンプルプログラムは，終了時間について雑に作ってますので注意してください）．
また，時刻の精度は $\Delta t$の取り方（評価する時刻が $\Delta t$で割り切れるか？）にも依存しますので，注意してください．

## 強制振動の分析
$c \neq 0$ の場合，時間とともに振動はなくなってしまうが，
 $u(t) = \sin ( \hat{\omega} t)$ のように，周期外力を加えたものは振動を続けることが知られている（強制振動）．そして，強制入力項の振動数がある特定の値になった際に，振動の振幅が大きくなる（共鳴）することが知られている．
```
応用課題2 cがゼロでない場合に，上記を実際に確かめてみよ．
様々な周波数で振動を加えて，時間とともに定常振動になるかを確認せよ．
また，周波数に応じて定常振動の振幅がどのように変化するかを調べてみよ．
（横軸周波数，縦軸振幅としたグラフを書いてみるとよい）
```

# SLIPモデルのシミュレーション
上記の復習をもとに，いよいよSLIPモデルのシミュレータ作成に取り組んでもらいます．

## SLIPモデルの運動

<img src="Figs/slip_motion.png" width="500" alt="SLIPモデルの運動">

SLIPモデルは，図のように質点と質量のないバネ（脚）が連結された保存系のシステムであり，脚が浮いている Flight phase（浮遊相）と，脚が地面に接地している Stance phase（接地相） の2つの運動フェーズを持つ．
Flight phase では，質点は放物運動をおこない，バネの姿勢は接地角 $\gamma_o$を保つ，一方で，足先が地面に接地するとStance phase に切り替わり，足先は地面に固定されたピンジョイントとしてふるまう．
Stance phase 内で，バネの長さが自然長になったら離地してFlight phase に戻るとともに，バネの角度を接地角 $\gamma_o$に戻して放物運動を再び行う．これらの2つの相の運動を繰り返し続ける．

## 運動方程式の導出

<img src="Figs/slip_model2.png" width="800" alt="SLIPモデル">

この質点の運動方程式は，ニュートンの運動方程式の導出方法で簡単に導出することができる．
上図のように，座標系と変数を定義する．質量 $m$，バネ定数 $k$，自然長 $l_0$，重力加速度 $g$と定義し，質点の位置を $(x, y)$と表す．また，Stance相での足先の接地座標を $x_{td}$とする．
この時，Flight phase の運動方程式は以下でかけ，
```math
m \ddot x  = 0,  m \ddot{y} = -mg
```
Stance phase での運動方程式は以下で書ける．
```math
m \ddot x  = - k (l_0 - l) \sin \gamma,  m \ddot{y} = k(l_0 - l)\cos \gamma - mg
```
なお，接地相でのバネの長さ $l$と 脚の角度 $\gamma$は以下であらわされる．
$$l = \sqrt{(x-x_{td})^2 + y^2}, \gamma = \arctan ( (x_{td} - x) / y)$$ 

Flight相からStance相への切り替わり条件は，脚が接地する条件 $y - l_0 \cos \gamma_o = 0$とかけ，StanceからFlight相への切り替わり条件は，バネの長さが自然長となった際の条件 $l - l_0 = 0$と求められる．

```
問3 上記の運動方程式を実際に自分で導出せよ
```

## 数値シミュレーション実装
上記の運動方程式を数値的に解くことを目指す．バネダンパ系の練習問題と同様に，運動方程式を1階の微分方程式に変換し，ルンゲクッタ法等の数値計算法を用いて解けば良い．
```
問4 上記のそれぞれの相の運動方程式を，1階の微分方程式に変換せよ．
今回は一般化座標が2変数であることに注意すること．
```
```
課題4 ルンゲクッタ法を用いて，運動方程式を数値計算するプログラムを書け．
```
Flight と Stance の切り替わりを判別し，運動方程式を切り替える必要があることに注意して実装すること．
ここでは，学習効果を高めるために，サンプルプログラムは与えません．課題１のプログラムの要領を復習しながら実装すること．

まずは Flight phase (あるいは Stance phase) のみの場合（切り替えがない場合）でシミュレータを作ってみて，それがうまく動くことを確認したのちに切り替わりを考慮するなど，順を追って作成すること．
プログラムは一気に作ってしまうと，バグとりが大変なことになる．方針が立たない場合ややることが分からない場合，教員やＴＡに遠慮なく相談してください．

### ヒント: SLIPの簡易動画作成プログラム
デバッグを行う上で，運動の様子を動画にしたほうが分かりやすいことがある．
以下のプログラムはgnuplotを使って，SLIPの運動を簡単な動画にするプログラムである．
なお，課題１と同様の時系列ファイルにおいて，2列目に質点のx座標，3列目に質点のy座標，6列目に脚バネの姿勢gamma，7列目にバネの長さがあると想定してプログラムしている．

```plaintext
# SLIP モデルの簡易アニメーション
# GIFアニメーションの設定
set terminal gif animate delay 10  # delayは各フレームの表示時間をミリ秒単位で指定 　データ間隔に合わせて調整
set output "slip_animation2.gif"

dt = 0.001 # シミュレのステップ刻み
span = 10 # 何個のデータおきに，図を描画するか 

# アニメーションの各フレームを描画
do for [i=0:200] {  # 200は描画回数。適切に変更してください。

    set title sprintf('Time : %f s', i * dt * span)
    set xlabel 'X'
    set ylabel 'Y'
    set size ratio 0.2
    set xrange [0:10]  # 必要に応じて変更
    set yrange [0:2]  # 必要に応じて変更
    unset key

    plot 'data_slip_run.dat' every ::span*i::span*i using 2:3 with points pt 7 notitle, 'data_slip_run.dat' every ::span*i::span*i  using ($2 + $7 * sin($6)):($3 - $7 * cos($6)) with points pt 3 notitle, 'data_slip_run.dat' every ::span*i::span*i using 2:3:($7 * sin($6)):(- $7 * cos($6)) with vectors nohead notitle
    # 2列目に質点のx座標，3列目にy座標があると想定，6列目にgamma，7列目にバネの長さ　があると想定
}
```
実行すると以下のように動くはずである．
![Animation](Figs/animation.gif)

## プログラムの妥当性の検討
練習と同様に，作ったプログラムが妥当である（バグがない）ことを検証します．
この運動方程式の解は解析的に求めることができない（意外だと思いますが．．．）．そのため，前回のような方法で妥当性を検証することはできない．
そこで，ここではシステムのエネルギーが保存することに着目してシミュレーションの妥当性を検証する．

### その場ジャンプ運動での妥当性検討
以下のパラメタを設定し，初期位置 $x = 0, y=1.5$ 初期速度 $\dot x =\dot y = 0$，接地時角度 $\gamma_o = 0$ を与えてシミュレーションを回してみよ．
| 変数 | 値   |   変数 | 値 |
| ------- | --------- | --------- | ------- |
| $m$   | 1 [kg]     |     $l_0$ |  1 [m]   |
| $k$   | 200 [N/m]    |     $g$ |  9.8 [m/s^2]   |
| 刻み幅 $dt$   | 0.001 [s]     |     シミュレ時間 $T$ | 10 [s]   |
```
課題5 状態変数 (x, y, dx/dt, dy/dt)の時間変化，バネの長さ l，バネの角度 gamma, 脚の接地情報 
ならびにシステムの全エネルギー E の時間変化をプロットして，プログラムがうまく動いているか確かめよ．
うまくいかない場合は，原因を分析してプログラムを修正せよ．
```

### 走行運動での妥当性検証
初期位置 $x = 0, y=1.05$ 初期速度 $\dot x = 6.455, \dot y = 0$，接地時角度 $\gamma_o = 0.54$ [rad] を与えてシミュレーションを回してみる．
```
課題6 状態変数 (x, y, dx/dt, dy/dt)の時間変化，バネの長さ l，バネの角度 gamma，脚の接地情報 
ならびにシステムの全エネルギーEの時間変化をプロットして，プログラムがうまく動いているか確かめよ．
うまくいかない場合は，原因を分析してプログラムを修正せよ．
```
上の課題を確かめる際は，短時間に地面と接地非接地を繰り返す（チャタリング）が起きていないかを念入りに確認してください．
10[s]後のエネルギー変化量が，単純計算で0.01程度のオーダーなら正常と判断できると思います．(この理由は応用課題3，4に関係します)

```
応用課題3 課題3と同様の評価をおこないたい．
1[s]後のエネルギーの誤差が，刻み幅dtとともにどのように変化するかを両対数グラフで示せ．
今回も4次の精度になっているだろうか？ なっていない場合は理由を考察せよ．
```
```
応用課題4 上記の応用課題3について，精度を上げるための解決策を思いつく場合はそれについて述べよ，
また，解決策を実装して効果を検証せよ．
```

## 数値実験
様々な初期値を与えてシミュレーションを行い，どんな運動が出るか調べて遊んでみましょう．人間のように周期的に走り続ける運動が出てくるでしょうか？
また，自身が作ったプログラムにバグがないか（特にイベント判定）について，さまざまな初期値を与えながらテストしてください．
初期位置$x = 0$，初期速度 $\dot y = 0$は固定して探してみること．

```
課題7 上述の取り組みで見つけた運動について周期的になっているものを2つ選び，
状態変数 (x, y, dx/dt, dy/dt)の時間変化をプロットして見よ．
また，初期y高さと初期x速度を少しずらしたときに（エネルギーは保存するようにずらす），
運動がどう変わるかも調べてみよ．
```

手作業で周期解を見つけるのはかなり大変だと思います．
特に思いつかない場合は，まず以下の2パターンをやってみましょう．
- 初期位置 $x = 0, y=1.05$ 初期速度 $\dot x = 6.455, \dot y = 0$，接地時角度 $\gamma_o = 0.54$ [rad]
- 初期位置 $x = 0, y=1.05$ 初期速度 $\dot x = 4.4023, \dot y = 0$，接地時角度 $\gamma_o = 0.43017$ [rad]
ちなみに，2つ目の例では，最後は地面より下に自由落下するはずです．
なぜなら，離地した際に足先を接地角 $\gamma_o$となるように決めますが，この際に足先が地面より下にあれば，脚は接地できないからです．
うまくプログラムできていたか確認してください．

次回の授業では，どうやって周期解を見つけるか？，どうやって安定性を評価するかについて説明します．

# 参考資料
- C＋＋言語に関する資料等
  - WEBサイト https://programming.pc-note.net/cpp/class2.html
- 数値計算法に関する資料等
  - WEBサイト「東京大学工学部 精密工学科 プログラミング応用 I・ II」 http://www.den.t.u-tokyo.ac.jp/ad_prog/ode/
- SLIPモデルに関する資料等
  - [Maziar A. Sharbafi and André Seyfarth, "Bioinspired Legged Locomotion, Models, Concepts, Control and Applications", 2017 Elsevier Inc., Chapter 3.](https://www.sciencedirect.com/book/9780128037669/bioinspired-legged-locomotion)
